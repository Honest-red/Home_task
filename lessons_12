# где пайтон ищет модули
#
# PYTHONPATH
import random
import pack1.p1.p123.p567.mod2 as module2

from pack1.p1.p123.p567.mod2 import func2 as f1
from pack1.p1.p123.p567.mod2 import func2 as f2
from pack1.p1.p123.p567.mod2 import func2 as f3
from pack1.p1.mod3 import func2 as f11
from pack1.p1.p123.p567.mod2 import func2 as f22, func3 as f33


# 1. проект мой, его директория
# 2. пайтон патч (PYTHONPATH)
# 3. систмная директория
# 4. виртуальное окружение моего проэкта

# модули могут быть 3х типов. файлы *.P, на языке С(питон может подключаться к библиотекам С. и им передавать что надо сделать),  стандартные модули.

# Для использования модуля, его надо проимпортировать. -  - любой файл с расширением ру, является модулем

#может вызывать как скрипт и как импортируемый модуль
# print(dir()) -  получить список пространства (стандартных) имен.магические(специальные). методы которые подключеного модуля.



# python.org - документация по пайтон
#
# print(dir.__doc__) - получить описание dir
# получить короткую справку по функции __doc__
#
# print(__file__) - получить путь к модулю
# print(__name__) -
#
#
# import random
# print(random.randint(10, 50))- после импорта по имени могу обратиться к его содержимому.
#
# файл init - обьявление папки пакетом. Если он есть, то он первым компилируется. Если что-то надо сделать до функции
#
# путь к модулю в модуле указывается через точку название всех пакетах при вызове
# ИЛИ назначить "кликчку" алиас  "as" - который потом можем вызывать. в виде as module
#
# вызов функции через фром, пишем фром путь к модулю импорт и название функции которая нас интересует в модуле.
#
# можно оджин и тотт же модуль назвать разными короткими именами и потом к ним обращаться.
# Используется если вызываемые функции имеют одинаковые название, использовать каждую можно через клички as
# можно вызывать из одного маршрута разнгые функции и назвачать им новые короткие имена для дальнейшего использования.
#
# когда мы ипортируем модуль он может исполняться после запуска если в ызываемом файле есть исполняемое действие(отладка).
# атрибут __name__ -  позволит спрятать отладку в испортируем модуле
# при импорте __name__ не будет его испольнять
# что бы исполнить надо запустить отладку в самом модуле
#
# делается через __name_,
# if __name__ == '__main__'
#     и тут пишем проверочную отладку
#
#
#
# Перезагрузка модуля, во время работы программы, модуля который ранее был импортирован.
#
# from importlib import reload
# после этой строки указываем испорт модуля который надо перезагрузить.
# import pack1.p1.mod3 as module3
#
# reload(module3)
_______________________________________________________________________________________________________________
2 вида ошибки - этапа компиляции(легко найти), этапа исполения(может вылезти через большой промежуток времени).
try: - в него можем поместить потенциально опасный код
except Предпологаемая ошибка, ее название as ex:
    print(ex)
    
Исключенеи Exсеption - исклбючение верхнего уровня, перехватывает все ошибки и которые мы ранее не обьявили...если не обьявили
обработка исключений должно быть по иерархии, тоесть от самого низкого потом старше и старше по иерархии ошибки.
Если наоборот сделаем, отработает но обработать и конкретно сказать в чем проблема не сможем, и как-то конкретно исправить
warning - не ошибка но обратьть внимание надо, т.к.  может сообщать о старом коде, вернее о старой библиотеки, которая сейчас 
работает но потом может быть удален. 
Если специфический код ошибки можем создать свой тип ошибки и потм обработывать.

Необязательный оператор try, else: - выполяется если не найдена ошибка.
                        finally: - выполяется в любом случае и результате работы  try.
                        (можно в этом описать закрытие файлов, освобождение ресурсов)

создание искуственно ошибку, на случай если пользователь ввел не правильные данные и мы хотим ему вывести ошибку что бы он ее исправил.

raise - ошибку которую хочук передать ..в скобках указать текст
