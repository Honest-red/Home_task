# можно не закрывать еслиь возможность использовать контектсный менеджер.
#
# file = open('test.txt', 'w') - стандартная работа с файлом
# file.write('Hello')
# file.close()
#
# пока мы находимося в контексте файл будет открыт, как только выйдем, файл автоматически закроется.
#
# оператор with  - контектстный менеджер
# with open('test.txt') as file: - в переменную  будет передан файл. как только выйдем из with файл автоматически будет закрыт
# file.closed - если Тру тогда закрты
# file.closed - если фоол тогда открыт


# with open('test.txt') as file:
#     file.closed
#     data = file.read()
#     print(data)
# file.closed
# # _________________________________________________________________________________________
# # with open('original.jpg', 'rb') as src:
#     # with open('result.jpg', 'rb') as dst:
#
#         # ИЛИ
#
# with open('original.jpg', 'rb') as src, open('result.jpg', 'rb') as dst:
# # _________________________________________________________________________________________
#     while True:
#         data = src.read(64)
#         if data:
#             dst.write(data)
#         else:
#             break



#             #ООП - объектно ориентированное проэктирование!

# объкт построенный по классу, по "инстуркции" и есть объектом.
# класс нужен для создания объекта.


#             Парадигма в которой описанно как действует код и данные с объектом
#
#             язык подчиняется 4м принципам:
# 1. Наследование - когда я беру другой класс и использую его функционал дописать свое.
# Создать свой класс на базе существующего
# я могу не создавать новый класс, а использовать существующий и дописать то чего мне не хватает.
#


# 2. Икопсуляция
# Прятать внутренню реализацию, оставляю только открытый интерфейс с которым можно безопастно взаимодейсвовать.
# обьеденяет код и данные которые внутри взаимодйтсввовать.
# Приватный  и публоичцый и зхащищенный
#
#
# 3. Полиморфизм
# использование различных обьектов с одинаковым интефейсом взаимодействия, не зависимо от принципа работы объекта.
#
#
# 4. Абстракция
# пользоваться объектом не задумываясь о его устройстве.
#

# Создангие класса
# class className (имя класса, имя пишется, если из нескольких слов то Каждое имя с большой буквы) () - Если есть список родителей(бьазовых классов), если наследник других классов
# Если не наследуется то никаких ()
#
# class className(parent1, parent2, ....):
#     pass
#
#
# class className:
#     pass


class Point: # - описывает точки на плоскости
    xx = 0 # - Атрибуты класса, их изменение влияент на изменение состояние объекта. Общие для всего класса
    yy = 0
    def __init__(self, x = 0, y = 0): # - конструктор
     self.x = x  # Атрибуты объекта - для каждого обхъекта свое значение
     self.y = y 
     
     #  self адресс объекта в котором он хранит    
     #__init__ Методы, магичсеские методы , предопределенны в любом класса, но ничего не делают. С их помощью мы можем переопределить.
pt1 = Point() # - создание объекта, объект класса Point
print(type(pt1), pt1)
print(pt1.x) # - Получить доступ к адрибутам, изменить - оператор .
pt1.x = 34 # - изменить атрибут в классе
print(pt1.x)
pt2 = Point(5, 6) - Передача параметров в конструктор атрибуты обхъекта
print(id(pt2), pt2.x, pt2.y, pt2.xx, pt2.yy)
pt3 = Point()
Point.xx - меняется параметры класса меняются через класс. Общие для всех объктов класса. Объект класса еще может называться экземплярами.
Любой класс содержит у же предустановленные Методы. Что бы они что-то сделали их надо переопределить.
Point.yy 
print(id(pt3), pt3.x, pt3.y)
pt4 = Point()
print(id(pt4), pt4.x, pt4.y)

Изменение переменной при ее инициализации(создание) использование констукттора(специальный Медок который существует в любом классе).
что бы поределитсь __doc__ к классу, его не обходимо в многострочном коментарии сразу же после названия класса указать.

__dict__ - пространсвто имен данного класса
